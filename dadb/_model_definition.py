''' _model_definition.py - structures to define models in DADB

Copyright (c) 2023 Netherlands Forensic Institute - MIT License
'''

from enum import EnumMeta as _EnumMeta
from collections import namedtuple as _nt

from ._datatype import equivalent_datatype as _equivalent_datatype
from ._datatype import basictypes as _basictypes
from ._schema import validname as _validname
from ._schema import tbl as _tbl
from ._schema import col as _col
from ._exceptions import FieldDefinitionError as _FieldDefinitionError
from ._exceptions import ModelDefinitionError as _ModelDefinitionError

# structure representing a model definition
#
# name:           model name
# fielddefs:      dict with field definitions
# explicit_dedup: deduplicate when modelitem is inserted explicitly
# implicit_dedup: deduplicate when modelitem is inserted as part of other modelitem insert
# fail_on_dup:    whether to raise exception (True) or return existing rowid (False)
#                 when duplicate entry is inserted
# source:         a description of the model source (i.e. custom, autogenerated, ...)
# version:        an integer version number
mdef_t = _nt('model_definition', 'name fielddefs explicit_dedup implicit_dedup fail_on_dup source version')

# structure representing a field definition
#
# name:           field name
# nullable:       True if field is allowed to be null
# multiple:       True if field can contain a list of values
# types:          a single datatype or list of datatypes (basic types, models or enums)
# preview:        True if field is included in previews
_fdef_t = _nt('field_definition', 'name nullable multiple types preview')


# struct for storing operational data on a single field
fdesc_t = _nt('fielddescriptor', 'name datatype submodel '
                                 'subenum maptables proptable '
                                 'nullable multiple '
                                 'columndef preview')

# struct for storing operational data on mapping tables
_maptabledescriptor = _nt('mapdescriptor', 'name enumtype modeltype tabledef query')

# struct for storing operational data on property tables
_proptabledescriptor = _nt('proptabledescriptor', 'name datatype tabledef')


def field_definition(name, types, nullable=True, preview=False):
    ''' function to create a field definition

    Arguments:

    name        : the name of the field
    types       : the type of the data (or a tuple of types)
    nullable    : whether the field is allowed to be NULL
    preview     : whether the field is to be included in previews such as the timeline
    '''

    # check if a single type or a tuple of types was provided
    if isinstance(types, tuple):
        # model definition/classes are tuples as well, these have a _fields property
        if hasattr(types, '_fields'):
            multiple = False
        else:
            multiple = True
            # now, check if the user tried to define more than 1 type
            if len(types) != 1:
                # using the API, this is not allowed.
                msg = 'it is not allowed to use non-uniform types in a field that holds a sequence'
                raise _FieldDefinitionError(msg)
    else:
        multiple = False

    return _fdef_t(name, nullable, multiple, types, preview)


def model_definition(name, fielddefs, source, version, explicit_dedup=False,
                     implicit_dedup=False, fail_on_dup=False):
    ''' function to create a model definition

    Arguments:
    name           : the name of the model
    fielddefs      : a list of field definitions
    source         : a string to make a note of the source of the model
    version        : an integer version number
    explicit_dedup : should explicit inserts be deduplicated (default: False)
    implicit_dedup : should implicit inserts be deduplicated (default: False)
    fail_on_dup    : should attempt to insert duplicate raise Exception (default: False)
    '''

    # Notes on explicit_dedup, implicit_dedup and fail_on_dup:
    #
    # There are 2 mechanisms for a modelitem to be added to a DADB database:
    #
    # - explicit: when a modelitem is created and inserted via de
    #             insert_modelitem function of the database
    #
    # - implicit: when a modelitem is part of another modelitem which in turn
    #             is inserted explicitly via the insert_modelitem function of
    #             the database
    #
    # By default insertion of a duplicate modelitem is allowed, because checking
    # for duplicates makes insertion of modelitems slower. Especially when a lot
    # of modelitems already exist this can add significant overhead. However, the
    # user can indicate in the modeldefinition whether or not duplicate items may
    # be inserted. This is done with 3 different arguments to the model_definition
    # function. The first two are described first:
    #
    # - explicit_dedup : If this option is True, DADB checks if a modelitem with
    #                    the exact same values in each field already exists when
    #                    it is inserted explicitly. If this is the case, the rowid
    #                    of the existing modelitem is returned. If there is no
    #                    duplicate found, a new modelitem is inserted and its rowid
    #                    is returned.
    #
    # - implicit_dedup : If this option is True, DADB checks if a modelitem with
    #                    the exact same values in each field already exists when
    #                    it is inserted implicitly. If this is the case, the rowid
    #                    of the existing modelitem is returned. If there is no
    #                    duplicate found, a new modelitem is inserted and its rowid
    #                    is returned.
    #
    # Note that if these two options are both True, no duplicates will ever be
    # inserted for this model and instead the existing modelitems will be used. In
    # this case we can never have any unintended duplicates. However, if one of
    # these options (or both) is set to False, duplicates may be inserted. If this
    # is undesireable, the third argument can be used:
    #
    # - fail_on_dup    : If this option is True, when a duplicate modelitem is
    #                    inserted, and deduplication is not enabled for the
    #                    insertion method (explicit or implicit), an exception will
    #                    be thrown.
    #
    # The first two options can be used to silently prevent duplicates by checking
    # for duplicates and returning the existing rowid. The third option can be seen
    # as a way to prevent duplicates explictly with a warning.
    #
    # The reason for handling explicit and implicit inserts differently is that
    # it may be allowed to refer to existing modelitems from some other
    # modelitem multiple times (i.e. implictly inserting an object multiple
    # times for different analysis results on this object). In this case, if we
    # insert the object multiple times in some other model's field, this will
    # result in the same rowid of the original object to be used each time.
    # However, when explicitly adding an object to the database, it is probably
    # not desireable to insert the same object multiple times. Instead,
    # insertion should fail; which is where fail_on_dup is useful.
    #
    # To understand this better, look at the different valid combinations of these
    # arguments:
    #
    # +-----+----------------+----------------+-------------+
    # |     | explicit_dedup | implicit_dedup | fail_on_dup |
    # +-----+----------------+----------------+-------------+
    # | 1)  | False          | False          | False       |
    # +-----+----------------+----------------+-------------+
    # | 2)  | False          | False          | True        |
    # +-----+----------------+----------------+-------------+
    # | 3)  | False          | True           | True        |
    # +-----+----------------+----------------+-------------+
    # | 4)  | True           | True           | False       |
    # +-----+----------------+----------------+-------------+
    #
    # 1) In this case no duplicate checking is done whatsoever. We can insert
    #    modelitems with the exact same fields multiple times and this will
    #    result in a new object in the database everytime.
    #
    # 2) In this case no duplicate inserts are allowed whatsoever. When an attempt
    #    is made to insert an already existing modelitem (i.e. all fields are equal
    #    to an existing modelitems fields), an exception will be raised. Note that
    #    this means that implicit inserts when a modelitem is part of some other
    #    model will also fail. This means that a modelitem may not be referred to
    #    by any other modelitem in one of its fields.
    #
    # 3) In this case no duplicates are allowed, but when inserting a modelitem
    #    as part of some other modelitem (implicit insert), the existing record is
    #    used when a duplicate is inserted. This is useful for when you want to
    #    prevent duplicate inserts, but allow for references to existing modelitems
    #    from some other model. This is probably the most common combination of
    #    these arguments.
    #
    # 4) In this case, deduplication is performed always and no error will be
    #    raised when a duplicate insert is detected.
    #
    # The other combinations of settings are not allowed, since they may lead to
    # confusing situations:
    #
    # +-----+----------------+----------------+-------------+
    # |     | explicit_dedup | implicit_dedup | fail_on_dup |
    # +-----+----------------+----------------+-------------+
    # | A)  | True           | False          | False       |
    # +-----+----------------+----------------+-------------+
    # | B)  | True           | False          | True        |
    # +-----+----------------+----------------+-------------+
    # | C)  | False          | True           | False       |
    # +-----+----------------+----------------+-------------+
    # | D)  | True           | True           | True        |
    # +-----+----------------+----------------+-------------+
    #
    # A) In this case whenever a user inserts an existing modelitem as part of some
    #    other modelitem (for example when a model used to record some analysis
    #    result with a reference to the model item on which the analysis was
    #    performed), a duplicate of the original modelitem is created.
    #
    # B) Similar to A, but in this case the insert is denied by fail_on_dup, which
    #    means that we can not use the original modelitem as part of the model
    #    holding the analysis results.
    #
    # C) In this case we can insert duplicates explicitly, but not as part of some
    #    other modelitem. There doesn't seem to be a use case for this.
    #
    # D) The fail_on_dup option is superfluous here, since all inserts will lead to
    #    deduplication.
    #

    if explicit_dedup is True and implicit_dedup is False:
        msg = 'invalid combination of explicit_dedup, implicit_dedup and fail_on_dup'
        raise _ModelDefinitionError(msg)

    if explicit_dedup is False and implicit_dedup is True and fail_on_dup is False:
        msg = 'invalid combination of explicit_dedup, implicit_dedup and fail_on_dup'
        raise _ModelDefinitionError(msg)

    if explicit_dedup is True and implicit_dedup is True and fail_on_dup is True:
        msg = 'invalid combination of explicit_dedup, implicit_dedup and fail_on_dup'
        raise _ModelDefinitionError(msg)

    if not isinstance(version, int):
        raise _ModelDefinitionError("version should be an integer")

    return mdef_t(name, fielddefs, explicit_dedup, implicit_dedup, fail_on_dup, source, version)


def check_fielddefinition(fielddefinition):
    ''' checks if the fielddefinition complies to constraints.

    When defining models, there are some restrictions on the type of fields,
    which are summarized here:

    1. A field may contain a basic datatype (or Data object)
    2. A field may contain a reference to another model
    3. A field may contain a reference to an Enum type
    4. A field may contain a sequence of modelitems
    5. A field may contain a sequence of Enum values
    6. A field may contain a sequence of basic datatypes

    In the case of Enum fields (case 3 and 6), no empty values are allowed in
    order to enforce that each modelitem has an appropriate value in that field.
    In all other cases, a field may optionally be nullable. '''

    err = "Error in fielddefinition: {:}".format(repr(fielddefinition))

    basictypes = [t.class_ for t in _basictypes.values()]

    if isinstance(fielddefinition.types, tuple):
        # a sequence of basic types, modelitems or enum values
        if len(fielddefinition.types) != 1:
            print(err)
            raise _FieldDefinitionError("only one type allowed in a sequence")

        if fielddefinition.multiple is False:
            print(err)
            raise _FieldDefinitionError("multiple should be True for sequence")

        if type(fielddefinition.types[0]) == _EnumMeta:
            # Enum sequences may not be Null (need at least one Enum value)
            if fielddefinition.nullable is True:
                print(err)
                raise _FieldDefinitionError("Enum fields may not be nullable")

        elif fielddefinition.types[0] in basictypes:
            # basic type: no constraints, may be nullable
            pass

        elif hasattr(fielddefinition.types[0], '_fields'):
            # Model: no constraints, may be nullable
            pass

        elif fielddefinition.types[0].__name__ == 'Data':
            # Data: not allowed in a sequence (not implemented)
            raise _FieldDefinitionError("multiple Data objects in a field not yet supported")

        else:
            print(err)
            raise _FieldDefinitionError("some unknown datatype was defined")

    else:
        if type(fielddefinition.types) == _EnumMeta:
            if fielddefinition.nullable is True:
                print(err)
                raise _FieldDefinitionError("Enum fields may not be nullable")

        elif fielddefinition.types in basictypes:
            # basic type: no constraints, may be nullable
            pass

        elif hasattr(fielddefinition.types, '_fields'):
            # Model: no constraints, may be nullable
            pass

        elif fielddefinition.types.__name__ == 'Data':
            # Data: no constraints, may be nullable
            pass

        else:
            print(err)
            raise _FieldDefinitionError("some unknown datatype was defined")


def convert_fielddefinitions(fielddefinitions):
    ''' converts fielddefs for which the type is a modeldefinition.

    Ideally, a modeldefinitions' fielddefinitions have a type field that
    is an actual datatype or a so called modelclass. However, for ease of
    defining models, we also allow the 'type' to be another
    modeldefinition. This function converts all fields for which this is
    the case to have a modelclass in the type field. '''

    new_fielddefs = []

    for fd in fielddefinitions:
        if type(fd.types) == mdef_t:
            tps = _nt(fd.types.name, ' '.join([k.name for k in fd.types.fielddefs]))
            newfd = fd._replace(types=tps)
            new_fielddefs.append(newfd)
        elif type(fd.types) == tuple:
            # deal with the case in which a tuple is given
            newtypes = []
            for t_ in fd.types:
                if type(t_) == mdef_t:
                    tp = _nt(t_.name, ' '.join([k.name for k in t_.fielddefs]))
                    newtypes.append(tp)
                else:
                    newtypes.append(t_)
            newfd = fd._replace(types=tuple(newtypes))
            new_fielddefs.append(newfd)
        else:
            new_fielddefs.append(fd)

    return new_fielddefs


def equivalent_fielddescriptors(fdesc1, fdesc2):
    ''' return True if two dictionaries of fielddescriptors are equivalent '''

    if not set(fdesc1.keys()) == set(fdesc2.keys()):
        return False

    for n, fd1 in fdesc1.items():
        fd2 = fdesc2[n]
        if fd1.name != fd2.name:
            return False
        if fd1.datatype != fd2.datatype:
            return False
        if not _equivalent_datatype(fd1.submodel, fd2.submodel):
            return False
        if not _equivalent_datatype(fd1.subenum, fd2.subenum):
            return False
        if not fd1.maptables == fd2.maptables:
            # we can just compare the list of mapdescriptors, since they are
            # all tuples with only string values.
            return False
        if not fd1.proptable == fd2.proptable:
            # proptable descriptor only contains string fields, compare
            # directly
            return False
        if not fd1.nullable == fd2.nullable:
            return False
        if not fd1.multiple == fd2.multiple:
            return False
        if not fd1.columndef == fd2.columndef:
            return False

    return True


def create_maptable_descriptor(modelname, fieldname, datatype, tableprefix, dbprefix):
    ''' creates a maptable descriptor '''

    # determine table name, based on the modelname, the fieldname and the name
    # of the subitem's type and prepend with tableprefix and dbprefix
    leftname = _validname(modelname, '')
    rightname = _validname(datatype.__name__, '')
    tblname = "%s_%s_x_%s" % (leftname, fieldname, rightname)
    tblname = _validname(tblname, tableprefix)
    tblname = _validname(tblname, dbprefix)

    # determine the name of the three fields by adding dbprefix
    leftname = _validname('leftid', dbprefix)
    rightname = _validname('rightid', dbprefix)
    indexname = _validname('element_index', dbprefix)

    # create a table structure
    mt = _tbl(tblname, 'auto-generated mapping table', (
             _col('%s' % (leftname,), 'id in "left" table', 'INTEGER NOT NULL'),
             _col('%s' % (rightname,), 'id in "right" table', 'INTEGER NOT NULL'),
             _col('%s' % (indexname,), 'index of element in sequence', 'INTEGER NOT NULL')),
             'UNIQUE (%s, %s, %s)' % (leftname, rightname, indexname))

    # decide whether enumtype or modeltype should be used
    if hasattr(datatype, '_fields'):
        modeltype = datatype.__name__
        enumtype = None
    elif type(datatype) == _EnumMeta:
        enumtype = datatype.__name__
        modeltype = None
    else:
        raise _FieldDefinitionError('mistake in maptable descriptor')

    # prepare the query for the mapper function
    q = '''SELECT * FROM {:s} WHERE {:s} == ? ORDER BY {:s}'''
    q = q.format(tblname, leftname, indexname)

    # return maptabledescriptor
    return _maptabledescriptor(fieldname, enumtype, modeltype, mt, q)


def create_proptable_descriptor(modelname, fieldname, typename, affinity, nullable, fieldprefix, tableprefix, dbprefix):
    ''' returns a table definiton for a property table '''

    # For basic types we create a property table instead of a mapping table,
    # just store the various values directly. Note that duplicate values in the
    # list of properties are also stored multiple times in the database.

    # construct the table name from the modelname and the fieldname
    tblname = "%s_%s" % (_validname(modelname, '') , _validname(fieldname, ''))
    # prefix the table name with tableprefix and dbprefix
    tblname = _validname(tblname, tableprefix)
    tblname = _validname(tblname, dbprefix)

    # The first columns is the id of the corresponding model item. We use
    # leftid to indicate that we have an n:m mapping.
    leftname = _validname('leftid', dbprefix)

    # The right column name is based on the fieldname, prefixed with
    # fieldprefix and dbprefix.
    rightname = _validname(fieldname, fieldprefix)
    rightname = _validname(rightname, dbprefix)
    # the element_index column is prefixed with the dbprefix
    indexname = _validname('element_index', dbprefix)

    # add NOT NULL to type affinity of the field if the field is not nullable
    if not nullable:
        affinity = affinity + ' NOT NULL'

    # create table structure
    pt = _tbl(tblname, 'auto-generated property table', (
             _col('%s' % (leftname,), 'id of modelentry', 'INTEGER NOT NULL'),
             _col('%s' % (rightname,), 'property', affinity),
             _col('%s' % (indexname,), 'index of element in sequence', 'INTEGER NOT NULL')),
             None)

    return _proptabledescriptor(fieldname, typename, pt)


def create_fielddescriptor(modelname, fielddefinition, datatypes, fieldprefix, tableprefix, dbprefix):
    ''' convert a fielddefinition into a fielddescriptor which is used to
    represent a field internally '''

    # create reverse datatypes lookup dict
    # NOTE: this dict is created for each call of create_fielddescriptor,
    #       which might seem expensive, but this function is only called
    #       a small relative number of times, so no need for optimization
    #       by pre-creating this dictionary and passing as argument.
    rev_datatypes={datatypes[name].class_:datatypes[name] for name in datatypes}

    # Note that this is a 'private' function and it should only
    # be called when modeldependencies are already resolved. No
    # need to check if the types are already known, this should already
    # have been taken care of (i.e. the required Enums and models should
    # already be in s.enums and s.models)

    # some shortcuts
    types = fielddefinition.types
    nullable = fielddefinition.nullable
    multiple = fielddefinition.multiple
    fieldname = fielddefinition.name
    preview = fielddefinition.preview

    # defaults for the fielddescriptor
    datatype, sqlitetype, subenum, submodel, columndef = (None,)*5
    maptbls = []
    proptbls = []

    if type(types) == tuple:
        # the field requires one or more mapping tables, one per type
        for tp in types:
            if hasattr(tp, '_fields') or type(tp) == _EnumMeta:
                # this is a model or an Enum, we need a mapping table
                mt = create_maptable_descriptor(modelname, fieldname, tp, tableprefix, dbprefix)
                maptbls.append(mt)
            else:
                # field holds multiple basic values, use property table
                affinity = rev_datatypes[tp].affinity
                typename = rev_datatypes[tp].name
                pt = create_proptable_descriptor(modelname, fieldname, typename, affinity,
                                                  nullable, fieldprefix, tableprefix, dbprefix)
                proptbls.append(pt)
    elif type(types) == _EnumMeta:
        # field holds pointer to enum
        sqlitetype = datatypes['Integer'].affinity
        subenum = types
    elif hasattr(types, '_fields'):
        # field holds pointer to modelitem
        sqlitetype = datatypes['Integer'].affinity
        submodel = types
    else:
        # field holds a basic datatype
        datatype = rev_datatypes[types].name
        sqlitetype = rev_datatypes[types].affinity

    # for non-mapping fields, create the columndefinition
    if sqlitetype is not None:
        if nullable is False:
            sqlitetype+=' NOT NULL'
        colname = _validname(fieldname, fieldprefix)
        colname = _validname(colname, dbprefix)
        columndef = _col(colname, 'autogenerated', sqlitetype)

    # from check_fielddefinition, we know that for fields that hold
    # multiple items, we should not have varying types, except for Models.
    # If this *does* occur however, this means that the list of
    # propertytables is > 1. This should not happen, but check just in case
    # we made a mistake somewhere.
    if len(proptbls) > 1:
        raise RuntimeError('Oh my, check_fielddefinition contains a bug')
    elif len(proptbls) == 1:
        proptable = proptbls[0]
    else:
        proptable = None

    return fdesc_t(fieldname, datatype, submodel, subenum,
                   maptbls, proptable, nullable,
                   multiple, columndef, preview)
